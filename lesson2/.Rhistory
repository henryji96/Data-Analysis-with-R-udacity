grid.arrange(p1,p2,p3,p4,ncol=2)
ggplot(data=subset(pf,!is.na(gender)),
aes(x=gender,y=friend_count))+
geom_boxplot()+
coord_cartesian(ylim=c(0,800))
names(pf)
by(pf$friendships_initiated,pf$gender,summary)
ggplot(data=subset(pf,!is.na(gender)),
aes(x=gender,y=friendships_initiated))+
geom_boxplot(outlier.colour = 'blue')+
coord_cartesian(ylim=c(0,150))+
scale_y_continuous(breaks = seq(0,150,10))
#It seems that female makes more friend requests
data("mtcars")
library(ggplot2)
library(gridExtra)
names(mtcars)
str(mtcars)
data("mtcars")
library(ggplot2)
library(gridExtra)
names(mtcars)
str(mtcars)
# There are two ways of zooming the plot display: with scales or
# with coordinate systems.  They work in two rather different ways.
p0<-ggplot(data=mtcars,aes(disp,wt))+
geom_point(color='black')+
geom_smooth()+
scale_x_continuous(breaks=seq(0,500,50))
# Setting the limits on a scale converts all values outside the range to NA.
p1<-p0+scale_x_continuous(limits = c(325, 500))
# Setting the limits on the coordinate system performs a visual zoom.
# The data is unchanged, and we just view a small portion of the original
# plot. Note how smooth continues past the points visible on this plot.
p2<-p0+coord_cartesian(xlim = c(325, 500))
# Simiarly, we can use expand = FALSE to turn off expansion with the
# default limits
p3<-p0+coord_cartesian(xlim = c(325, 500),expand = FALSE)
grid.arrange(p0,p1,p2,p3,ncol=2)
getwd()
setwd('F:/learn_data/R/Data-Analysis-with-R_udacity/lesson3')
getwd()
setwd(''/Users/henry/Desktop/data_science/Data_Analysis_with_R_udacity/lesson3')
pf<-read.csv('pseudo_facebook.tsv',sep='\t')
getwd()
setwd('/Users/henry/Desktop/data_science/Data_Analysis_with_R_udacity/lesson3')
pf<-read.csv('pseudo_facebook.tsv',sep='\t')
summary(pf$mobile_likes)
summary(pf$mobile_likes>0)
length(pf$mobile_likes[pf$mobile_likes>0])
pf$mobile_check_in<-factor(ifelse(pf$mobile_likes>0,TRUE,FALSE))
summary(pf$mobile_check_in)
pf$mobile_likes>0
pf<-read.csv('pseudo_facebook.tsv',sep='\t')
getwd()
setwd('/Users/henry/Desktop/data_science/Data_Analysis_with_R_udacity/lesson3')
pf<-read.csv('pseudo_facebook.tsv',sep='\t')
summary(pf$mobile_likes)
summary(pf$mobile_likes>0)
length(pf$mobile_likes[pf$mobile_likes>0])
pf$mobile_check_in<-factor(ifelse(pf$mobile_likes>0,TRUE,FALSE))
summary(pf$mobile_check_in)
library(ggplot2)
?diamonds
data("diamonds")
dim(diamonds)
summary(diamonds)
str(diamonds)
table(diamonds$color)
# You can save images by using the ggsave() command.
# ggsave() will save the last plot created.
# For example...
#                  qplot(x = price, data = diamonds)
#                  ggsave('priceHistogram.png')
# ggsave currently recognises the extensions eps/ps, tex (pictex),
# pdf, jpeg, tiff, png, bmp, svg and wmf (windows only).
ggplot(data=diamonds,
aes(x=price))+
geom_histogram(binwidth=800,fill='pink',color='grey')+
facet_wrap(~cut,scales='free_y')+
scale_x_continuous(breaks=seq(0,20000,10000))
# In the last exercise, we looked at the summary statistics
# for diamond price by cut. If we look at the output table, the
# the median and quartiles are reasonably close to each other.
by(diamonds$price,diamonds$cut,summary)
# This means the distributions should be somewhat similar,
# but the histograms we created don't show that.
# The 'Fair' and 'Good' diamonds appear to have
# different distributions compared to the better
# cut diamonds. They seem somewhat uniform
# on the left with long tails on the right.
getwd()
library(ggplot2)
pf<-read.csv('pseudo_facebook.tsv',sep='\t')
summary(pf$age)
#plus operator add a new layer to our figure
ggplot(data=pf,
aes(x=age,y=friend_count))+
geom_point(shape=6) +
xlim(13,90)
#It's going to take 20 points to be equivalent of one of these black dots.
library(gridExtra)
p1<-ggplot(data=pf,
aes(x=age,y=friend_count))+
geom_point(shape=1,size=1,alpha=1/20)+
xlim(13,90)
#age is a continuous variable, but I only have integer variables, so are are seeing the perfectly lined up columns, which isn't a true reflection of age.
#Using jitter, we can add some noise to each age so we can get a clearer picture about the relationship between age and friend count.
p2<-ggplot(data=pf,
aes(x=age,y=friend_count))+
geom_jitter(shape=1,size=1,alpha=1/20)+
xlim(13,90)
grid.arrange(p1,p2,ncol=1)
p3<-ggplot(data=pf,
aes(x=age,y=friend_count))+
geom_jitter(shape=1,size=1,alpha=1/20,
position=position_jitter(height=0))+
xlim(13,90)+
coord_trans(x="log2")
p3
library(ggplot2)
data(diamonds)
names(diamonds)
# The difference between transforming the scales and
# transforming the coordinate system is that scale
# transformation occurs BEFORE statistics(plot), and coordinate
# transformation afterwards.
# Coordinate transformation also changes the shape of geoms:
#  * by transforming the data
d <- subset(diamonds, carat > 0.5)
p1<-ggplot(data=d,
aes(x=log10(carat),y=log10(price)))+
geom_point(alpha=1/20)+
geom_smooth(method='lm')
#  * by transforming the scales
p2<-ggplot(data=d,
aes(x=carat,y=price))+
geom_point(alpha=1/20,size=2,shape=1)+
geom_smooth(method='lm')+
scale_x_log10()+
scale_y_log10()
#  * by transforming the coordinate system
p3<-ggplot(data=d,
aes(x=carat,y=price))+
geom_point(alpha=1/20,size=2,shape=1)+
coord_trans(x="log10",y="log10")+
geom_smooth(method='lm')
p1
p2
p3
df <- data.frame(a = abs(rnorm(26)),letters)
df
ggplot(data=df,
aes(a,letters))+
geom_point()+
coord_trans(x = "sqrt")
library(dplyr)
library(ggplot2)
pf<-read.delim('pseudo_facebook.tsv')
str(pf)
pf_a<-arrange(pf,age,dob_year,desc(tenure))
head(pf_a)
# Select columns by name
s1<-select(pf,age,dob_year)
head(s1)
# Select all columns between Year and DayOfWeek (inclusive)
s2<-select(pf, age:dob_year)
head(s2)
# Select all columns except Year and DayOfWeek
s3<-select(pf, -(age:dob_year))
head(s3)
pf_m<-mutate(pf,
friend_received=friend_count-friendships_initiated,
tenure_y=tenure/365
)
head(pf_m,8)
summarise(pf,
tenure_med=median(tenure,na.rm = TRUE),
age_avg=mean(age,na.rm = TRUE)
)
#str(pf)
pf_f<-filter(pf,!is.na(gender),!is.na(tenure))
names(pf_f)
##first groupby,second summarise
age_groups<-group_by(pf_f,age)
pf_by_age<-summarise(age_groups,
count=n(),
tenure_avg=mean(tenure),
tenure_IQR=IQR(tenure)
)
pf_by_age
##same result
by(pf_f$tenure,pf_f$gender,mean)
ggplot(data=pf_by_age,
aes(x=age,y=tenure_avg))+
geom_point(aes(size=tenure_avg),alpha=1/5)+
geom_smooth()
dob_day_groups<-group_by(pf,dob_year,dob_day,dob_month)
pf_by_dob<-summarise(dob_day_groups,
age_avg=mean(age),
tenure_avg=mean(tenure))
pf_by_dob
df <- data.frame(x = c('a','b','c','a','b','e','d','f'),
y = c(1,2,3,4,5,6,7,8),
z = c(8,7,6,5,4,3,2,1))
df2tbl <- tbl_df(df)
str(df2tbl)
head(df2tbl,2)
filter(df2tbl,x!='a',x!='b',y!=8)
summarize(df2tbl, max(y),n(),last(x),n_distinct(x))
x_groups<-group_by(df2tbl,x)
str(x_groups)
summarize(group_by(df2tbl,x),count=n())
df <- data.frame(x = c('a','b','c','a','b','e','d','f'),
y = c(1,2,3,4,5,6,7,8),
z = c(1,1,1,2,3,3,2,1))
df2tbl <- tbl_df(df)
df2<-data.frame(x=c('a','b','m'),a=c('A','B','C'),b=c(1,2,3))
df2tbl2<-tbl_df(df2)
#join by both dataset's common x value
inner_join(x=df2tbl,y=df2tbl2,by='x')
#join by both dataset's all x value
full_join(x=df2tbl,y=df2tbl2,by='x')
#join by left dataset's x value
left_join(x=df2tbl,y=df2tbl2,by='x')
#join by right dataset's x balue
right_join(x=df2tbl,y=df2tbl2,by='x')
mydf1 <- data.frame(x = c(1,2,3,4), y = c(10,20,30,40))
mydf2 <- data.frame(x = c(5,6), y = c(50,60))
mydf3 <- data.frame(z = c(100,200,300,400))
bind_rows(mydf1, mydf2)
bind_cols(mydf1, mydf3)
inner_join(x=df2tbl,y=df2tbl2,by='x') %>%
group_by(z) %>%
summarize(count=n(),mean_y=mean(y))
eco<-arrange(economics,date)
date<-eco$date
date[1:3]
length(date)
library(ggplot2)
library(dplyr)
library(gridExtra)
data("economics")
head(economics)
str(economics)
summary(economics)
library(ggplot2)
library(dplyr)
library(gridExtra)
data("economics")
head(economics)
str(economics)
summary(economics)
recent<-filter(economics,date>as.Date("2013-01-01"))
p1<-ggplot(recent,
aes(date,unemploy))+
geom_line(aes(color=date))
p2<-ggplot(recent,
aes(date,unemploy))+
geom_step(aes(color=date))
p3<-ggplot(recent,
aes(date,unemploy))+
geom_path(aes(color=date))
grid.arrange(p1,p2,p3,ncol=1)
m <- ggplot(economics, aes(unemploy/pop, psavert))
p1<-m + geom_point()
p2<-m + geom_path(aes(color=as.numeric(date)))
grid.arrange(p1,p2,ncol=1)
?arrow
p1<-ggplot(economics, aes(date, unemploy)) +
geom_line(aes(colour = date))
# Use the arrow parameter to add an arrow to the line
# See ?arrow for more details
p2<-ggplot(economics, aes(x = date, y = pop))+
geom_line(arrow = arrow(angle = 15,
ends = "both", type = "closed"))
grid.arrange(p1,p2,ncol=1)
#NAs break the line. Use na.rm = T to suppress the warning message
df <- data.frame(x = 1:5, y = c(4,1,NA,9,14))
df
ggplot(df,aes(x,y))+
geom_path(size=1, linejoin = "mitre",
lineend='round',linetype=3)+
geom_point(size=2,aes(color=x))
pf<-read.csv("pseudo_facebook.tsv",sep='\t')
library(ggplot2)
library(dplyr)
ggplot(data=pf,
aes(x=age,y=friend_count))+
xlim(13,90)+
geom_point(alpha=0.05,
position=position_jitter(h=0),
color='orange')+
coord_trans(y='sqrt')+
coord_cartesian(xlim=c(13,70),ylim=c(0,1000))+##zoom
geom_line(stat='summary',fun.y=mean)+
geom_line(stat='summary',
fun.y=quantile,fun.args=list(probs =0.1),
linetype=2,color='blue')+
geom_line(stat='summary',
fun.y=quantile,fun.args=list(probs =0.9),
linetype=2,color='blue')
#summary line are the mean friend count by age over my raw data
?cor.test
#default to use the pearson method
#method1
cor.test(pf$age,pf$friend_count,method = "pearson")
#method2
#with function evaluate an R expression in an environment constructed from data.
with(pf,cor.test(age,friend_count))
with(filter(pf, age<50) , cor.test(age, friend_count))
ggplot(data=pf,
aes(x=www_likes_received,
y=likes_received))+
geom_point(alpha=1/8)+
geom_line(stat='summary',fun.y=quantile,fun.args=list(probs=0.95))+
xlim(0,quantile(pf$www_likes_received,0.95))+
ylim(0,quantile(pf$likes_received,0.95))+
geom_smooth(method='lm',color='red')
ggplot(data=pf,
aes(x=www_likes_received,
y=likes_received))+
geom_point(alpha=1/8)+
geom_line(stat='summary',fun.y=quantile,fun.args=list(probs=0.95),color='pink')+
coord_cartesian(xlim=c(0,quantile(pf$www_likes_received,0.95)),
ylim=c(0,quantile(pf$likes_received,0.95)))+
geom_smooth(method='lm',color='red')
with(pf,cor.test(www_likes_received,likes_received,method='pearson'))
ggplot(data=Mitchell,
aes(x=Month,y=Temp))+
geom_point()+
geom_line()
#install.packages('alr3')
library(alr3)
#By looking at this dataset, we will see how correlation can be deceptive.
data(Mitchell)
str(Mitchell)
head(Mitchell)
ggplot(data=Mitchell,
aes(x=Month,y=Temp))+
geom_point()+
geom_line()
str(geom_line)
library(gridExtra)
range(Mitchell$Month)
with(Mitchell,cor.test(Month,Temp,method='pearson'))
p1<-ggplot(data=Mitchell,
aes(x=Month,y=Temp))+
geom_point()+
scale_x_continuous(breaks=seq(0,203,12))
p2<-ggplot(data=Mitchell,
aes(x=(Month%%12),y=Temp))+
geom_point()+
scale_x_continuous(breaks=seq(0,203,12))
grid.arrange(p1,p2,ncol=1)
#install.packages('energy')
library(energy)
x <- seq(0, 4*pi, pi/20)
y <- cos(x)
qplot(x = x, y = y)
dcor.ttest(x, y)
cor.test(x,y)
library(dplyr)
library(ggplot2)
pf<-read.csv('pseudo_facebook.tsv',sep='\t')
##group my dataframe by age
age_groups<-group_by(pf,age)
pf.fc_by_age<-summarise(age_groups,
friend_count_mean=mean(friend_count),
friend_count_median=median(as.numeric(friend_count)),
friend_count_IQR=IQR(friend_count),
n=n() #number of users in each group
)
head(pf.fc_by_age)
#It can be seen that the black line have a lot of random noise.
#The mean friend_count rises and falls over each age.
#The spike at age 69 does not make sense.
#Actually, we just have a sample from the data generating process
#So the estimated friend_count_mean is the true mean plus some noise.
#We could infer that the noise of this plot could be worse if we choose finer bins for age.
ggplot(data=pf.fc_by_age,
aes(age,friend_count_mean))+
geom_line()
#We will have more x values, since age will be measured in months rather than years. The bin will be thing.
pf$age_with_month<-pf$age+(12-pf$dob_month)/12
age_month_groups<-group_by(pf,age_with_month)
pf.fc_by_age_month<-summarise(age_groups2,
friend_count_mean=mean(friend_count),
friend_count_median=median(as.numeric(friend_count)),
friend_count_IQR=IQR(friend_count),
n=n() #number of users in each group
)
#We will have more x values, since age will be measured in months rather than years. The bin will be thing.
pf$age_with_month<-pf$age+(12-pf$dob_month)/12
age_month_groups<-group_by(pf,age_with_month)
pf.fc_by_age_month<-summarise(age_groups,
friend_count_mean=mean(friend_count),
friend_count_median=median(as.numeric(friend_count)),
friend_count_IQR=IQR(friend_count),
n=n() #number of users in each group
)
p1<-ggplot(data=filter(pf.fc_by_age,age<70),
aes(age,friend_count_mean))+
geom_line()+
geom_point(alpha=1/2)+
geom_smooth()
#data is a lot worse as to age_with_month
#we have finer bin
#more data points
p2<-ggplot(data=filter(pf.fc_by_age_month,age_with_month<70),
aes(age_with_month,friend_count_median))+
geom_line(stat='summary',fun.y=mean,color='red')+
geom_point(alpha=1/5)+
geom_smooth()
#We will have more x values, since age will be measured in months rather than years. The bin will be thing.
pf$age_with_month<-pf$age+(12-pf$dob_month)/12
age_month_groups<-group_by(pf,age_with_month)
pf.fc_by_age_month<-summarise(age_groups2,
friend_count_mean=mean(friend_count),
friend_count_median=median(as.numeric(friend_count)),
friend_count_IQR=IQR(friend_count),
n=n() #number of users in each group
)
#We will have more x values, since age will be measured in months rather than years. The bin will be thing.
pf$age_with_month<-pf$age+(12-pf$dob_month)/12
age_month_groups<-group_by(pf,age_with_month)
pf.fc_by_age_month<-summarise(age_groups2,
friend_count_mean=mean(friend_count),
friend_count_median=median(as.numeric(friend_count)),
friend_count_IQR=IQR(friend_count),
n=n() #number of users in each group
)
pf<-read.csv("pseudo_facebook.tsv",sep='\t')
library(dplyr)
library(ggplot2)
ggplot(aes(x = gender, y = age),
data = subset(pf, !is.na(gender))) +
geom_boxplot()+
stat_summary(fun.y=mean,geom='point',shape=4)
#Everywhere the median friend_count is larger for women than it is for man
#There are some noisy estimates for our old users.
ggplot(data=subset(pf,!is.na(gender)),
aes(x=age,y=friend_count))+
geom_line(aes(color=gender),stat='summary',fun.y=median)
pf.fc_by_age<-pf %>%
filter(!is.na(gender)) %>%
group_by(age,gender) %>%
summarise(fc_mean=mean(friend_count),
fc_median=median(as.numeric(friend_count)),
n=n()) %>%
arrange(age)
ggplot(data=pf.fc_by_age,
aes(x=age,y=fc_median))+
geom_line(aes(color=gender),stat='summary',fun.y=median)+
geom_smooth()
ggplot(aes(x = gender, y = age),
data = subset(pf, !is.na(gender))) +
geom_boxplot()+
stat_summary(fun.y=mean,geom='point',shape=4)
#Everywhere the median friend_count is larger for women than it is for man
#There are some noisy estimates for our old users.
ggplot(data=subset(pf,!is.na(gender)),
aes(x=age,y=friend_count,color=gender))+
geom_line(stat='summary',fun.y=median)
ggplot(data=filter(pf,!is.na(gender)),
aes(x=age,y=friend_count))+
facet_grid(.~gender)+
geom_line(stat='summary',fun.y=median)
head(pf.fc_by_age)
#install.packages('reshape2')
library(reshape2)
#long to wide
#choose the long dataset's key-value pair
pf.fc_by_age_gender.wide<-
dcast(pf.fc_by_age,
age~gender,
value.var = 'fc_median')
head(pf.fc_by_age_gender.wide)
library(gridExtra)
age_male<-ggplot(data=pf.fc_by_age_gender.wide,
aes(x=age,y=male))+
geom_line()
age_female<-ggplot(data=pf.fc_by_age_gender.wide,
aes(x=age,y=female))+
geom_line()
grid.arrange(age_male,age_female,ncol=2)
ggplot(data=pf.fc_by_age_gender.wide,
aes(x=age,y=female/male))+
geom_line()+
geom_point(alpha=1/5)+
geom_hline(yintercept = 1,alpha=0.5,linetype=2)+
geom_vline(xintercept = c(30,60,90),
alpha=0.5,linetype=4)
?geom_hline
par()
cur_par<-par()
par(col.lab='red')
hist(mtcars$mpg)
ggplot(mtcars,
aes(mpg))+
geom_histogram(binwidth=1)
pf$year_joined<-floor(2014-pf$tenure/365)
table(pf$year_joined)
str(pf$year_joined)
pf$year_joined.bucket<-cut(pf$year_joined,
c(2004,2009,2011,2012,2014))
table(pf$year_joined.bucket,useNA = 'ifany')
str(pf$year_joined.bucket)
ggplot(data=filter(pf,!is.na(year_joined.bucket)),
aes(x=age,
y=friend_count))+
geom_line(aes(color=year_joined.bucket),stat='summary',fun.y=median)
